{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Longmetal Docs","text":"<p>Documentation for code and drive related Longmetal Robotics topics.</p> <p>For helpful general robotics docs see:</p> <p>docs.wpilib.org - general robot coding concepts and WpiLib navigation</p> <p>docs.photonvision.org - vision system docs</p> <p>https://docs.oracle.com/javase/tutorial/java/TOC.html - general Java syntax + OOP Concepts</p> <p>(add more?) </p>"},{"location":"editing-code/","title":"Editing Code","text":""},{"location":"editing-code/#accessing-and-deploying-code","title":"Accessing and Deploying Code","text":"<ol> <li>If you are reading this, you probably already got a computer with the code on it. If not, find either CC1, CC2, or the other Dell laptop (not CAD laptop).</li> <li>Before anything else, open GitHub Desktop (you can look it up with the Windows Icon to find it). At the top bar, it will say \"Fetch Origin\", press this. </li> <li>Get the controllers listed in the robot's Controller Bindings page (docs.longmetal.org) and plug it into one of the USB slots in the computer.</li> <li>Within the computer, open the latest WPILib VSCode (Search WPILib, the icon is a W surrounded by a gear). You should be able to open it from the Windows Desktop, or start Menu.</li> <li>In WPILIB VSCode, there should be the words \"Open a folder\" in blue text (it is located at the \"Get Started\" tab which opens at launch. Click that. It will open up the computer's files.</li> <li>Find the robot code. To find the folder name, open the Wiki tab for the robot you want to run. </li> <li>Back in VSCode, you should see a little icon at the top left, click it. This will let you see the different files associated with the robot folder. One file in the root folder is called \"build.gradle\". This builds all the code for the robot so that you can run it. Right click on the \"build.gradle\" file name and a list of options should show up. Click on \"Deploy robot code\" towards the bottom. </li> </ol> <p>Tip</p> <p>Read the style guide before editing code</p>"},{"location":"starting-robot/","title":"Starting The Robot","text":"<p>If you changed code, see Editing and Deploying Code</p>"},{"location":"starting-robot/#turning-on-the-robot","title":"Turning On The Robot","text":"<ol> <li>Get the robot that you are trying to launch. Also get a battery (2023 ones).</li> <li>Plug the battery into the robot and push the switch, highlighted in yellow in the image below, to turn on the robot.</li> <li>Connect to the internet needed for the robot you are trying to start. See that robots docs to find the internet name.  </li> </ol>"},{"location":"starting-robot/#running-code","title":"Running Code","text":"<ol> <li>If you are reading this, you probably already got a computer with the code on it. If not, find either CC1, CC2, or the other Dell laptop (not CAD laptop).</li> <li>Get the controllers listed in the robot's Controller Bindings page (docs.longmetal.org) and plug it into one of the USB slots in the computer.</li> <li>If it isn't already open, open Driver Station from the Windows Start Menu. You can look this up by pressing the Windows button in the buttom right. </li> <li>Open the  tab within the driver station. Within that tab there should be an Enable and Disable switch. When enabled, the robot can move, and vice versa for when it's disabled. </li> <li>After making sure no one is nearby, press enable. The robot code is now enabled and the robot can move.</li> </ol> <p>Warning</p> <p>Sometimes the controller will recognize inputs but not move the robot after enabling the code. One reason for this is that Driverstation may be configured with the wrong USB slot for the controller. To check, navigate to the  tab in Driverstation. Within there, make sure your controller (the one flashing green after you press a button) is in the correct slot documented in the robot's Controller Bindings page. The icon of the controller currently plugged in will be green, drag this to the position specified in the docs for the robot you are trying to run. </p>"},{"location":"starting-robot/#turning-off-the-robot","title":"Turning Off the Robot","text":"<ol> <li>In the code, press disable to turn off the code, so you won't get hurt while turning off the robot.</li> <li>Press the red button on the robot's breaker to turn it off. This cuts all power to the robot, so it is safe to interact with any normally powered mechanisms. </li> </ol>"},{"location":"style-guide/","title":"Code Style Guide","text":"<p>This is a general style and naming guide for Longmetal code.</p>"},{"location":"style-guide/#general","title":"General","text":""},{"location":"style-guide/#naming","title":"Naming","text":"<ul> <li>Use descriptive names. This is the most important rule. If you can't tell what a variable is for from its name, it's not a good name.</li> <li>Use camelCase for variables and methods. This means that the first word is lowercase, and every word after that is capitalized. For example, <code>thisIsCamelCase</code>.</li> <li>Use PascalCase for classes. This means that every word is capitalized. For example, <code>ThisIsPascalCase</code>.</li> <li>Prefix constants with <code>k</code>. For example, <code>kThisIsAConstant</code>. Most constants should be in a central Constants class.</li> <li>Prefix private variables with <code>m</code>. For example, <code>mThisIsAPrivateVariable</code>.</li> </ul>"},{"location":"style-guide/#formatting","title":"Formatting","text":"<ul> <li>Format code with prettier. Prettier is a code formatter that automatically formats code to a consistent style. It is available as a VSCode extension, and a CLI.</li> <li>Comment! All code should be clear and well commented. Complex code should have a comment explaining what it does. All methods should have a JavaDoc comment explaining what they do and what arguments they accept. Most constants should have a comment explaining their value and units. All comments should be clear and concise.</li> </ul>"},{"location":"style-guide/#commands","title":"Commands","text":"<p>Most commands should be written as inline lambda commands. For example: <pre><code>drive.setDefaultCommand(new RunCommand(() -&gt; { \n    double multiplier = (((joystick.getThrottle() * -1) + 1) / 2); // turbo mode\n    double z = RobotContainer.joystick.getZ() / 1.5;\n\n    drive.drive(\n        -MathUtil.applyDeadband(joystick.getY() * multiplier, OperatorConstants.kDriveDeadband),\n        MathUtil.applyDeadband(joystick.getX() * multiplier, OperatorConstants.kDriveDeadband),\n        MathUtil.applyDeadband(z * multiplier, OperatorConstants.kDriveDeadband),\n        true,\n        true);\n\n}, drive));\n</code></pre> Only commands that require a large amount of state should be written as a separate class. However, if a command is tracking a large amount of state, consider rewriting parts into the subsystem.</p>"},{"location":"style-guide/#subsystems","title":"Subsystems","text":"<p>Subsystems should be written as a class that extends <code>SubsystemBase</code> in the subsystems folder. They should have a <code>periodic()</code> method that is called every robot loop. Subsystems should be instantiated in <code>RobotContainer</code>. Everything should be a train. <code>ArmTrain</code>. <code>DriveTrain</code>. <code>GripperTrain</code>. It just makes sense. If you disagree, you are wrong, unless you are Jack.</p>"},{"location":"style-guide/#button-bindings","title":"Button Bindings","text":"<p>Button bindings are written in <code>RobotContainer</code>. If you update or create a binding, make sure to update the controller bindings page on the wiki.</p>"},{"location":"style-guide/#constants","title":"Constants","text":"<p>Constants should be stored in a central <code>Constants</code> class. They should be grouped in subclasses by subsystem or function. Constants should be named in <code>PascalCase</code>, and prefixed with <code>k</code>. For example, <code>kArmPosition</code>.</p>"},{"location":"Bumper-Bots/","title":"Bumper Bots","text":"<p>We use Bumper Bots for STEM nights, among other reasons. There are two robots, Yella Fella (yellow) and Funny Lad (black) The code for these is different because Funny Lad runs on Spark Maxs, and Yella Fella runs on Sparks.</p> <p>Warning! One of the Xbox/Logitech CONTROLLERS (not joysticks) works better with one of the bumper bots. Experiment to see which works. </p> <ul> <li>The code for Funny Lad is  here.</li> <li> <p>The code for Yella Fella is here</p> </li> <li> <p>WIFI for Yella Fella: <code>7127_MajorTom</code></p> </li> <li>WIFI for Funny Lad: <code>7127</code></li> <li>Funny Lad Folder is <code>Funny-Lad</code></li> <li>Yella Fella folder is <code>Yella-Fella</code></li> </ul>"},{"location":"Bumper-Bots/controller-bindings/","title":"Controller Bindings","text":""},{"location":"Bumper-Bots/controller-bindings/#xbox-controller-port-0","title":"XBOX Controller (Port 0)","text":""},{"location":"Jurassic-Sparks/","title":"Jurassic Sparks","text":"<p>More Cowbell was our 2024 bot. The code is here.</p> <ul> <li>WIFI: <code>7127-swervy</code></li> <li>Folder: <code>24Bot</code></li> </ul>"},{"location":"Jurassic-Sparks/controller-bindings/","title":"Controller Bindings","text":""},{"location":"Jurassic-Sparks/controller-bindings/#xbox-controller-port-1","title":"XBOX Controller (Port 1)","text":""},{"location":"Jurassic-Sparks/controller-bindings/#thrustmaster-port-0","title":"Thrustmaster (Port 0)","text":""},{"location":"More-Cowbell/","title":"More Cowbell","text":"<p>More Cowbell was our 2023 bot. The code is  here.</p> <ul> <li>WIFI: <code>7127-morecowbell</code></li> <li>Folder: <code>MoreCowbell</code> or <code>7127Robot2023</code></li> </ul>"},{"location":"More-Cowbell/controller-bindings/","title":"Controller Bindings","text":""},{"location":"More-Cowbell/controller-bindings/#xbox-controller-port-1","title":"XBOX Controller (Port 1)","text":""},{"location":"More-Cowbell/controller-bindings/#thrustmaster-port-0","title":"Thrustmaster (Port 0)","text":""}]}